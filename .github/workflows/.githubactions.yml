name: CI/CD – Docker Hub & Elastic Beanstalk (AL2 Multi-Container)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  # Tag everything with the commit SHA
  SHA: ${{ github.sha }}

  # Docker Hub namespace (org/username)
  DOCKERHUB_NAMESPACE: ${{ secrets.DOCKERHUB_USERNAME }}

  # AWS / EB
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EB_APPLICATION_NAME: ${{ secrets.EB_APPLICATION_NAME }}
  EB_ENVIRONMENT_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}

  # Image repo names on Docker Hub
  CLIENT_IMAGE: react-client
  SERVER_IMAGE: node-server
  WORKER_IMAGE: node-worker
  NGINX_IMAGE: nginx-router

jobs:
  test_client:
    name: Test React client (Dockerized)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build the client test stage (Node-based) and load it locally
      - name: Build client test image (target=test)
        uses: docker/build-push-action@v6
        with:
          context: ./client
          file: ./client/Dockerfile
          target: test
          load: true
          tags: client-test:local

      # Run tests (the test stage CMD runs them)
      - name: Run client tests
        run: docker run --rm -e CI=true client-test:local
  build_and_push:
    name: Build & Push images (skip unchanged)
    runs-on: ubuntu-latest
    needs: [test_client]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 1) Detect which folders changed
      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          # Adjust paths if your structure differs
          filters: |
            client:
              - 'client/**'
            server:
              - 'server/**'
            worker:
              - 'worker/**'
            nginx:
              - 'nginx/**'
            common:
              - 'docker-compose.yml'
              - '.github/workflows/**'

      # Helper: function to safely retag (copy) an existing tag to the new SHA tag
      # Uses imagetools to copy the current :latest digest to :${SHA} without rebuilding
      - name: Enable imagetools (for retagging)
        run: |
          docker buildx version
          # buildx imagetools is available with setup-buildx-action; nothing else needed

      # 2) CLIENT
      - name: Build & Push – client (changed)
        if: steps.changes.outputs.client == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./client
          file: ./client/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: |
            NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:latest

      - name: Retag – client (unchanged)
        if: steps.changes.outputs.client != 'true'
        run: |
          # Reuse existing digest (prefer latest) and assign the new SHA tag
          SRC="${DOCKERHUB_NAMESPACE}/${CLIENT_IMAGE}:latest"
          DST="${DOCKERHUB_NAMESPACE}/${CLIENT_IMAGE}:${SHA}"
          echo "Retagging ${SRC} -> ${DST}"
          docker buildx imagetools create -t "${DST}" "${SRC}"
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          CLIENT_IMAGE: ${{ env.CLIENT_IMAGE }}
          SHA: ${{ env.SHA }}

      # 3) SERVER (API)
      - name: Build & Push – server (changed)
        if: steps.changes.outputs.server == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: |
            NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:latest

      - name: Retag – server (unchanged)
        if: steps.changes.outputs.server != 'true'
        run: |
          SRC="${DOCKERHUB_NAMESPACE}/${SERVER_IMAGE}:latest"
          DST="${DOCKERHUB_NAMESPACE}/${SERVER_IMAGE}:${SHA}"
          echo "Retagging ${SRC} -> ${DST}"
          docker buildx imagetools create -t "${DST}" "${SRC}"
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          SERVER_IMAGE: ${{ env.SERVER_IMAGE }}
          SHA: ${{ env.SHA }}

      # 4) WORKER
      - name: Build & Push – worker (changed)
        if: steps.changes.outputs.worker == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./worker
          file: ./worker/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: |
            NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:latest

      - name: Retag – worker (unchanged)
        if: steps.changes.outputs.worker != 'true'
        run: |
          SRC="${DOCKERHUB_NAMESPACE}/${WORKER_IMAGE}:latest"
          DST="${DOCKERHUB_NAMESPACE}/${WORKER_IMAGE}:${SHA}"
          echo "Retagging ${SRC} -> ${DST}"
          docker buildx imagetools create -t "${DST}" "${SRC}"
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          WORKER_IMAGE: ${{ env.WORKER_IMAGE }}
          SHA: ${{ env.SHA }}

      # 5) NGINX
      - name: Build & Push – nginx (changed)
        if: steps.changes.outputs.nginx == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./nginx
          file: ./nginx/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:latest

      - name: Retag – nginx (unchanged)
        if: steps.changes.outputs.nginx != 'true'
        run: |
          SRC="${DOCKERHUB_NAMESPACE}/${NGINX_IMAGE}:latest"
          DST="${DOCKERHUB_NAMESPACE}/${NGINX_IMAGE}:${SHA}"
          echo "Retagging ${SRC} -> ${DST}"
          docker buildx imagetools create -t "${DST}" "${SRC}"
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          NGINX_IMAGE: ${{ env.NGINX_IMAGE }}
          SHA: ${{ env.SHA }}
  deploy_eb:
    name: Deploy to Elastic Beanstalk (AL2 Multi-Container w/ Compose v3)
    runs-on: ubuntu-latest
    needs: [build_and_push]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Create EB bundle (no secrets)
        run: |
          set -euo pipefail
          : "${DOCKERHUB_NAMESPACE:?DOCKERHUB_NAMESPACE is required}"
          : "${SHA:?SHA is required}"

          # Only non-sensitive vars for image resolution & diagnostics
          echo "DOCKERHUB_NAMESPACE=${DOCKERHUB_NAMESPACE}" > .env
          echo "TAG=${SHA}" >> .env
          echo "GIT_SHA=${SHA}" >> .env

          # Zip compose + .env (EB reads these to resolve images)
          zip -q "app-${SHA}.zip" docker-compose.yml .env
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          SHA: ${{ env.SHA }}

      - name: Upload bundle to S3
        run: |
          set -euo pipefail
          aws s3 cp "app-${SHA}.zip" "s3://${S3_BUCKET}/app-${SHA}.zip"
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
          SHA: ${{ env.SHA }}

      - name: Register EB application version
        run: |
          set -euo pipefail
          aws elasticbeanstalk create-application-version \
            --application-name "${EB_APPLICATION_NAME}" \
            --version-label "${SHA}" \
            --source-bundle S3Bucket="${S3_BUCKET}",S3Key="app-${SHA}.zip"
        env:
          EB_APPLICATION_NAME: ${{ env.EB_APPLICATION_NAME }}
          S3_BUCKET: ${{ env.S3_BUCKET }}
          SHA: ${{ env.SHA }}

      - name: Deploy (Update EB environment)
        run: |
          set -euo pipefail
          aws elasticbeanstalk update-environment \
            --environment-name "${EB_ENVIRONMENT_NAME}" \
            --version-label "${SHA}"
        env:
          EB_ENVIRONMENT_NAME: ${{ env.EB_ENVIRONMENT_NAME }}
          SHA: ${{ env.SHA }}

      - name: Wait for EB environment update to finish
        run: |
          set -euo pipefail
          # Wait until the update completes (success or failure)
          aws elasticbeanstalk wait environment-updated \
            --environment-names "${EB_ENVIRONMENT_NAME}"

          # Optional: surface final health/status
          aws elasticbeanstalk describe-environments \
            --environment-names "${EB_ENVIRONMENT_NAME}" \
            --query "Environments[0].{Status:Status, Health:Health, HealthStatus:HealthStatus, Version:VersionLabel, Endpoint:EndpointURL}" \
            --output table
        env:
          EB_ENVIRONMENT_NAME: ${{ env.EB_ENVIRONMENT_NAME }}
