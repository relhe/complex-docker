name: CI/CD – Build · Scan · Deploy · Verify

on:
  pull_request:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: "Force rebuild all images (skip change detection)"
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  SHA: ${{ github.sha }}
  DOCKERHUB_NAMESPACE: ${{ secrets.DOCKERHUB_USERNAME }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EB_APPLICATION_NAME: ${{ secrets.EB_APPLICATION_NAME }}
  EB_ENVIRONMENT_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  CLIENT_IMAGE: react-client
  SERVER_IMAGE: node-server
  WORKER_IMAGE: node-worker
  NGINX_IMAGE: nginx-router

jobs:
  # ── 1. DETECT CHANGES ──────────────────────────────────────────────────────
  # Centralised change detection so every build job reads from one source of
  # truth.  The `common` filter (compose file, workflow changes) forces a full
  # rebuild of all images, as does the manual force_rebuild input.
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      client: ${{ steps.out.outputs.client }}
      server: ${{ steps.out.outputs.server }}
      worker: ${{ steps.out.outputs.worker }}
      nginx:  ${{ steps.out.outputs.nginx  }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            common:
              - 'docker-compose.yml'
              - '.github/workflows/**'
            client:
              - 'client/**'
            server:
              - 'server/**'
            worker:
              - 'worker/**'
            nginx:
              - 'nginx/**'

      # force_rebuild OR any change to shared files rebuilds everything
      - name: Resolve final change flags
        id: out
        run: |
          FORCE="${{ github.event.inputs.force_rebuild }}"
          COMMON="${{ steps.filter.outputs.common }}"
          if [[ "$FORCE" == "true" || "$COMMON" == "true" ]]; then
            echo "client=true" >> "$GITHUB_OUTPUT"
            echo "server=true" >> "$GITHUB_OUTPUT"
            echo "worker=true" >> "$GITHUB_OUTPUT"
            echo "nginx=true"  >> "$GITHUB_OUTPUT"
          else
            echo "client=${{ steps.filter.outputs.client }}" >> "$GITHUB_OUTPUT"
            echo "server=${{ steps.filter.outputs.server }}" >> "$GITHUB_OUTPUT"
            echo "worker=${{ steps.filter.outputs.worker }}" >> "$GITHUB_OUTPUT"
            echo "nginx=${{ steps.filter.outputs.nginx }}"   >> "$GITHUB_OUTPUT"
          fi

  # ── 2a. BUILD · TEST · PUSH · SCAN – client ────────────────────────────────
  # Tests run first (only when source changed), blocking the production push.
  # Registry cache (buildcache tag) keeps layer reuse between runs.
  build_client:
    name: Build client
    runs-on: ubuntu-latest
    needs: changes
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build test stage
        if: needs.changes.outputs.client == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./client
          file: ./client/Dockerfile
          target: test
          load: true
          tags: client-test:ci
          cache-from: type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:buildcache

      - name: Run client tests
        if: needs.changes.outputs.client == 'true'
        run: docker run --rm -e CI=true client-test:ci

      - name: Build & push (changed)
        if: needs.changes.outputs.client == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./client
          file: ./client/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:buildcache,mode=max

      - name: Retag (unchanged)
        if: needs.changes.outputs.client != 'true'
        run: |
          docker buildx imagetools create \
            -t ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:${{ env.SHA }} \
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:latest

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.CLIENT_IMAGE }}:${{ env.SHA }}
          format: table
          severity: CRITICAL,HIGH
          exit-code: "0"   # set to "1" to block on findings

  # ── 2b. BUILD · PUSH · SCAN – server ───────────────────────────────────────
  build_server:
    name: Build server
    runs-on: ubuntu-latest
    needs: changes
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push (changed)
        if: needs.changes.outputs.server == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:buildcache,mode=max

      - name: Retag (unchanged)
        if: needs.changes.outputs.server != 'true'
        run: |
          docker buildx imagetools create \
            -t ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:${{ env.SHA }} \
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:latest

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.SERVER_IMAGE }}:${{ env.SHA }}
          format: table
          severity: CRITICAL,HIGH
          exit-code: "0"

  # ── 2c. BUILD · PUSH · SCAN – worker ───────────────────────────────────────
  build_worker:
    name: Build worker
    runs-on: ubuntu-latest
    needs: changes
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push (changed)
        if: needs.changes.outputs.worker == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./worker
          file: ./worker/Dockerfile
          push: true
          platforms: linux/amd64
          build-args: NODE_ENV=production
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:buildcache,mode=max

      - name: Retag (unchanged)
        if: needs.changes.outputs.worker != 'true'
        run: |
          docker buildx imagetools create \
            -t ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:${{ env.SHA }} \
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:latest

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.WORKER_IMAGE }}:${{ env.SHA }}
          format: table
          severity: CRITICAL,HIGH
          exit-code: "0"

  # ── 2d. BUILD · PUSH · SCAN – nginx ────────────────────────────────────────
  build_nginx:
    name: Build nginx
    runs-on: ubuntu-latest
    needs: changes
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push (changed)
        if: needs.changes.outputs.nginx == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ./nginx
          file: ./nginx/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:${{ env.SHA }}
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:buildcache,mode=max

      - name: Retag (unchanged)
        if: needs.changes.outputs.nginx != 'true'
        run: |
          docker buildx imagetools create \
            -t ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:${{ env.SHA }} \
            ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:latest

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.DOCKERHUB_NAMESPACE }}/${{ env.NGINX_IMAGE }}:${{ env.SHA }}
          format: table
          severity: CRITICAL,HIGH
          exit-code: "0"

  # ── 3. DEPLOY TO ELASTIC BEANSTALK ─────────────────────────────────────────
  # Gates on all 4 build jobs (parallel fan-in).
  # Captures the current EB version before deploying so rollback has a target.
  # The `environment: production` key enables the GitHub Environments approval
  # gate – configure required reviewers in repo Settings → Environments.
  deploy_eb:
    name: Deploy to production
    runs-on: ubuntu-latest
    needs: [build_client, build_server, build_worker, build_nginx]
    environment: production
    outputs:
      previous_version: ${{ steps.prev.outputs.label }}
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Capture current EB version (rollback target)
        id: prev
        run: |
          PREV=$(aws elasticbeanstalk describe-environments \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}" \
            --query "Environments[0].VersionLabel" \
            --output text 2>/dev/null || echo "None")
          echo "label=${PREV}" >> "$GITHUB_OUTPUT"
          echo "Previous version: ${PREV}"

      - name: Create deployment bundle
        run: |
          set -euo pipefail
          : "${DOCKERHUB_NAMESPACE:?}"
          : "${SHA:?}"
          echo "DOCKERHUB_NAMESPACE=${DOCKERHUB_NAMESPACE}" > .env
          echo "TAG=${SHA}"                                >> .env
          echo "GIT_SHA=${SHA}"                           >> .env
          zip -q -r "app-${SHA}.zip" docker-compose.yml .env .platform/
        env:
          DOCKERHUB_NAMESPACE: ${{ env.DOCKERHUB_NAMESPACE }}
          SHA: ${{ env.SHA }}

      - name: Upload bundle to S3
        run: aws s3 cp "app-${SHA}.zip" "s3://${S3_BUCKET}/app-${SHA}.zip"
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
          SHA: ${{ env.SHA }}

      - name: Register EB application version
        run: |
          set -euo pipefail
          aws elasticbeanstalk create-application-version \
            --application-name "${{ env.EB_APPLICATION_NAME }}" \
            --version-label    "${{ env.SHA }}" \
            --source-bundle S3Bucket="${{ env.S3_BUCKET }}",S3Key="app-${{ env.SHA }}.zip"

      - name: Deploy new version
        run: |
          set -euo pipefail
          aws elasticbeanstalk update-environment \
            --environment-name "${{ env.EB_ENVIRONMENT_NAME }}" \
            --version-label    "${{ env.SHA }}"

      - name: Wait for environment to be Ready
        run: |
          set -euo pipefail
          aws elasticbeanstalk wait environment-updated \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}"
          aws elasticbeanstalk describe-environments \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}" \
            --query "Environments[0].{Status:Status,Health:Health,HealthStatus:HealthStatus,Version:VersionLabel,Endpoint:EndpointURL}" \
            --output table
        env:
          EB_ENVIRONMENT_NAME: ${{ env.EB_ENVIRONMENT_NAME }}

  # ── 4. SMOKE TEST ───────────────────────────────────────────────────────────
  # Probes the live endpoints with retries.  Fails the workflow (triggering
  # rollback) if any endpoint stays unhealthy after all attempts.
  smoke_test:
    name: Smoke test
    runs-on: ubuntu-latest
    needs: deploy_eb
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Resolve application URL
        id: url
        run: |
          ENDPOINT=$(aws elasticbeanstalk describe-environments \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}" \
            --query "Environments[0].EndpointURL" \
            --output text)
          echo "base=http://${ENDPOINT}" >> "$GITHUB_OUTPUT"
          echo "Application URL: http://${ENDPOINT}"

      - name: Probe health endpoints (5 retries, 15 s apart)
        run: |
          BASE="${{ steps.url.outputs.base }}"
          probe() {
            local path="$1" expected="$2"
            echo "Probing ${BASE}${path} (expecting HTTP ${expected})"
            for i in 1 2 3 4 5; do
              CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${BASE}${path}" 2>/dev/null || echo "000")
              echo "  attempt ${i}: HTTP ${CODE}"
              [[ "$CODE" == "$expected" ]] && return 0
              sleep 15
            done
            echo "FAILED: ${path} never returned ${expected}" >&2
            return 1
          }
          probe "/api/values/all"     "200"
          probe "/api/values/current" "200"
          echo "All smoke tests passed."

      - name: Write job summary
        if: always()
        run: |
          BASE="${{ steps.url.outputs.base }}"
          {
            echo "## Smoke Test – $(date -u '+%Y-%m-%d %H:%M UTC')"
            echo "**Deployed version:** \`${{ env.SHA }}\`"
            echo "**URL:** ${BASE}"
            echo ""
            echo "| Endpoint | HTTP | Result |"
            echo "|----------|------|--------|"
            for path in "/api/values/all" "/api/values/current"; do
              CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${BASE}${path}" 2>/dev/null || echo "ERR")
              RESULT=$([[ "$CODE" == "200" ]] && echo "PASS" || echo "FAIL")
              echo "| \`${path}\` | ${CODE} | ${RESULT} |"
            done
          } >> "$GITHUB_STEP_SUMMARY"

  # ── 5. AUTO-ROLLBACK ON SMOKE FAILURE ──────────────────────────────────────
  # Runs only when the smoke test fails but the deploy itself succeeded
  # (i.e. the new version is bad, not an infra outage).
  rollback:
    name: Rollback to previous version
    runs-on: ubuntu-latest
    needs: [deploy_eb, smoke_test]
    if: |
      failure() &&
      needs.deploy_eb.result == 'success' &&
      needs.deploy_eb.outputs.previous_version != 'None' &&
      needs.deploy_eb.outputs.previous_version != ''
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Roll back to ${{ needs.deploy_eb.outputs.previous_version }}
        run: |
          PREV="${{ needs.deploy_eb.outputs.previous_version }}"
          echo "Smoke tests failed for ${{ env.SHA }} — rolling back to ${PREV}"
          aws elasticbeanstalk update-environment \
            --environment-name "${{ env.EB_ENVIRONMENT_NAME }}" \
            --version-label    "${PREV}"

      - name: Wait for rollback to complete
        run: |
          aws elasticbeanstalk wait environment-updated \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}"
          aws elasticbeanstalk describe-environments \
            --environment-names "${{ env.EB_ENVIRONMENT_NAME }}" \
            --query "Environments[0].{Status:Status,Health:Health,Version:VersionLabel}" \
            --output table
        env:
          EB_ENVIRONMENT_NAME: ${{ env.EB_ENVIRONMENT_NAME }}

      - name: Annotate summary
        run: |
          {
            echo "## ROLLBACK TRIGGERED"
            echo "Smoke tests failed for version \`${{ env.SHA }}\`."
            echo "Rolled back to: \`${{ needs.deploy_eb.outputs.previous_version }}\`"
          } >> "$GITHUB_STEP_SUMMARY"
